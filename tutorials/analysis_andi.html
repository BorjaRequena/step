<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="We benchmark STEP study anomalous diffusion with changes.">

<title>STEP - Benchmark: anomalous diffusion</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../styles.css">
<meta property="og:title" content="STEP - Benchmark: anomalous diffusion">
<meta property="og:description" content="We benchmark STEP study anomalous diffusion with changes.">
<meta property="og:image" content="https://BorjaRequena.github.io/step/tutorials/02_analysis_andi_files/figure-html/cell-13-output-1.png">
<meta property="og:site-name" content="STEP">
<meta property="og:image:height" content="385">
<meta property="og:image:width" content="559">
<meta name="twitter:title" content="STEP - Benchmark: anomalous diffusion">
<meta name="twitter:description" content="We benchmark STEP study anomalous diffusion with changes.">
<meta name="twitter:image" content="https://BorjaRequena.github.io/step/tutorials/02_analysis_andi_files/figure-html/cell-13-output-1.png">
<meta name="twitter:image-height" content="385">
<meta name="twitter:image-width" content="559">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../logo.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">STEP</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/BorjaRequena/step" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../tutorials/index_tutorials.html">Tutorials</a></li><li class="breadcrumb-item"><a href="../tutorials/analysis_andi.html">Benchmark: anomalous diffusion</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Getting started</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false">
 <span class="menu-text">Documentation</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Data</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/baselines.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Baselines</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../source/utils.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Utils</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../tutorials/index_tutorials.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Tutorials</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/model_training.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Model training</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/analysis_bm.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Benchmark: Brownian motion</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/analysis_andi.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Benchmark: anomalous diffusion</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../tutorials/anomalous_from_normal.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Anomalous diffusion from normal diffusion</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#load-the-model" id="toc-load-the-model" class="nav-link active" data-scroll-target="#load-the-model">Load the model</a></li>
  <li><a href="#pointwise-prediction" id="toc-pointwise-prediction" class="nav-link" data-scroll-target="#pointwise-prediction">Pointwise prediction</a>
  <ul class="collapse">
  <li><a href="#generate-the-data" id="toc-generate-the-data" class="nav-link" data-scroll-target="#generate-the-data">Generate the data</a></li>
  <li><a href="#get-the-predictions" id="toc-get-the-predictions" class="nav-link" data-scroll-target="#get-the-predictions">Get the predictions</a></li>
  <li><a href="#prediction-error" id="toc-prediction-error" class="nav-link" data-scroll-target="#prediction-error">Prediction error</a></li>
  <li><a href="#error-by-anomalous-diffusion-model" id="toc-error-by-anomalous-diffusion-model" class="nav-link" data-scroll-target="#error-by-anomalous-diffusion-model">Error by anomalous diffusion model</a></li>
  <li><a href="#error-by-diffusion-model-and-localization-noise" id="toc-error-by-diffusion-model-and-localization-noise" class="nav-link" data-scroll-target="#error-by-diffusion-model-and-localization-noise">Error by diffusion model and localization noise</a>
  <ul class="collapse">
  <li><a href="#process-the-trajectories" id="toc-process-the-trajectories" class="nav-link" data-scroll-target="#process-the-trajectories">Process the trajectories</a></li>
  <li><a href="#overall-performance" id="toc-overall-performance" class="nav-link" data-scroll-target="#overall-performance">Overall performance</a></li>
  <li><a href="#mae-as-function-of-sigma_textnoise" id="toc-mae-as-function-of-sigma_textnoise" class="nav-link" data-scroll-target="#mae-as-function-of-sigma_textnoise">MAE as function of <span class="math inline">\(\sigma_{\text{noise}}\)</span></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#changepoint-detection" id="toc-changepoint-detection" class="nav-link" data-scroll-target="#changepoint-detection">Changepoint detection</a>
  <ul class="collapse">
  <li><a href="#generate-the-data-1" id="toc-generate-the-data-1" class="nav-link" data-scroll-target="#generate-the-data-1">Generate the data</a></li>
  <li><a href="#get-the-predictions-1" id="toc-get-the-predictions-1" class="nav-link" data-scroll-target="#get-the-predictions-1">Get the predictions</a></li>
  <li><a href="#overall-performance-1" id="toc-overall-performance-1" class="nav-link" data-scroll-target="#overall-performance-1">Overall performance</a></li>
  <li><a href="#difference-between-segments" id="toc-difference-between-segments" class="nav-link" data-scroll-target="#difference-between-segments">Difference between segments</a>
  <ul class="collapse">
  <li><a href="#change-point-position" id="toc-change-point-position" class="nav-link" data-scroll-target="#change-point-position">Change point position</a></li>
  </ul></li>
  </ul></li>
  </ul>
<div class="toc-actions"><div><i class="bi bi-github"></i></div><div class="action-links"><p><a href="https://github.com/BorjaRequena/step/issues/new" class="toc-action">Report an issue</a></p></div></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Benchmark: anomalous diffusion</h1>
</div>

<div>
  <div class="description">
    We benchmark STEP study anomalous diffusion with changes.
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<p>The main goal is to characterize anomalous diffusion processes that switch between diffusive states without any kind of prior konwledge. In this tutorial, we focus on inferring the anomalous diffusion exponent <span class="math inline">\(\alpha\)</span> at every time step, which naturally highlights potential changes in the behaviour along the trajectories. This allows us to obtain a deeper understanding of the underlying physical systems that drive the dynamics.</p>
<p>In the following analysis, we provide a thorough characterization of the model performance under various conditions and we show how to reproduce some figures of <a href="https://arxiv.org/abs/2302.00410">our paper</a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This tutorial is very similar to the <a href="https://borjarequena.github.io/step/tutorials/analysis_bm.html">Benchmark: Brownian motion</a>. Thus, we skip some extended explanations here and we refer to this one instead.</p>
</div>
</div>
<section id="load-the-model" class="level1">
<h1>Load the model</h1>
<p>First of all, we need to load a trained model with which to perform the analysis.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>We refer to the <a href="https://borjarequena.github.io/step/tutorials/model_training.html">model training tutorial</a> for details about how to train and save your models.</p>
</div>
</div>
<p>To load the models within a <code>Leaner</code>, we need to provide some data loaders. However, we will use the model to study various scenarios, so we provide an empty dataloader and load the different data sets as we need them.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dls <span class="op">=</span> DataLoaders.from_dsets([], []) <span class="co"># Empty train and validation datasets</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> XResAttn(dim, n_class<span class="op">=</span><span class="dv">1</span>, stem_szs<span class="op">=</span>(<span class="dv">32</span>,), conv_blocks<span class="op">=</span>[<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>                 block_szs<span class="op">=</span>[<span class="dv">128</span>, <span class="dv">256</span>, <span class="dv">512</span>], pos_enc<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                 n_encoder_layers<span class="op">=</span><span class="dv">4</span>, dim_ff<span class="op">=</span><span class="dv">512</span>, nhead_enc<span class="op">=</span><span class="dv">8</span>, linear_layers<span class="op">=</span>[])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>model.to(default_device())</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>learn_exp <span class="op">=</span> Learner(dls, model, loss_func<span class="op">=</span>L1LossFlat(), model_dir<span class="op">=</span>MODEL_PATH)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can load the trained model weights.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>learn_exp.load(<span class="ss">f'xresattn_exp_</span><span class="sc">{</span>dim<span class="sc">}</span><span class="ss">d_1_to_4_cp'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>learn_exp.model.<span class="bu">eval</span>()<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>It is very important to define the model exactly with the same layers as we did during training. Otherwise, we won’t be able to load the trained parameters!</p>
</div>
</div>
</section>
<section id="pointwise-prediction" class="level1">
<h1>Pointwise prediction</h1>
<p>We study the overall performance of the method over anomalous diffusion trajectories that present changes both in the underlying anomalous diffusion model, and the anomalous diffusion exponent <span class="math inline">\(\alpha\)</span>. We look at the pointwise prediction error and study how the length of the segments within the trajectory affect it.</p>
<p>We compare our approach with a reference method based on the time-averaged mean squared displacement (TA-MSD) (see <a href="https://borjarequena.github.io/step/source/baselines.html">baselines</a>). However, since this method cannot account for any heterogeneity in the trajectories, we provide it with the pre-segmented trajectories. This results in a massive advantage and, thus, we also pass the pre-cut segments through our model.</p>
<p>With this segment-wise analysis, we can easily study the performance of all the methods as function of the segment lengths.</p>
<section id="generate-the-data" class="level2">
<h2 class="anchored" data-anchor-id="generate-the-data">Generate the data</h2>
<p>To evaluate the different methods, we need a proper test set. We can generate one in the same way that we genereate the train set in the <a href="https://borjarequena.github.io/step/tutorials/model_training.html">model training tutorial</a>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Skip the data generation if you already have a test set!</p>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># OPTIONAL: create the test set.</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Don't need to run this cell if it already exists.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>n_per_set <span class="op">=</span> <span class="dv">12500</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>max_t <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">2</span> </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>cps <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>ds_fun <span class="op">=</span> partial(create_andi_segmentation_dataset,</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                 max_t<span class="op">=</span>max_t, dim<span class="op">=</span>dim, noise<span class="op">=</span>[<span class="fl">0.</span>], save<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>datasets <span class="op">=</span> [ds_fun(n_per_set, n_change_points<span class="op">=</span>n_cp) <span class="cf">for</span> n_cp <span class="kw">in</span> cps]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> combine_datasets(datasets)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>n_change <span class="op">=</span> <span class="ss">f"</span><span class="sc">{</span><span class="bu">min</span>(cps)<span class="sc">}</span><span class="ss">_to_</span><span class="sc">{</span><span class="bu">max</span>(cps)<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>save_path <span class="op">=</span> DATA_PATH<span class="op">/</span>get_andids_fname(n_change, max_t, dim, <span class="st">"test"</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>dataset.to_pickle(save_path)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Load the test set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Skip this cell if you just generated it.</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>n_change <span class="op">=</span> <span class="st">"1_to_4"</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>name <span class="op">=</span> <span class="st">"test"</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> load_dataset(n_change<span class="op">=</span>n_change, dim<span class="op">=</span>dim, name<span class="op">=</span>name)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="get-the-predictions" class="level2">
<h2 class="anchored" data-anchor-id="get-the-predictions">Get the predictions</h2>
<p>We now perform the predictions of the trajectories store them in the dataframe to process them later. First, we compute the full-trajectory predictions. Then, we proceed with the segment-wise analysis. We split the trajectories and their predictions by the <em>true</em> changepoints. Then, we perform the prediction especifically for each segment with both the model and the TA-MSD method. We use the TA-MSD 2-10 to perform the evaluation.</p>
<p>Let’s define a prediction function and a normalization function to simplify the code.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict_norm_sample(model, x):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Get the `model` prediction normalizing a single sample `x`."</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    xb <span class="op">=</span> x.unsqueeze(<span class="dv">0</span>).to(default_device())</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    xb_norm <span class="op">=</span> normalize(xb)[<span class="dv">0</span>]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> to_detach(model(xb_norm).squeeze())</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> normalize(trajs):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Normalize a batch of trajectories."</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    bs, _, dim <span class="op">=</span> trajs.shape</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    trajs <span class="op">-=</span> trajs.mean(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    displ <span class="op">=</span> trajs[:, <span class="dv">1</span>:] <span class="op">-</span> trajs[:, :<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    std <span class="op">=</span> displ.std(<span class="dv">1</span>, keepdim<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    std <span class="op">=</span> torch.where(std <span class="op">==</span> <span class="fl">0.</span>, torch.ones_like(std), std)</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    displ <span class="op">/=</span> std</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    trajs_norm <span class="op">=</span> displ.cumsum(<span class="dv">1</span>)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    trajs_norm <span class="op">=</span> torch.cat([torch.zeros(bs, <span class="dv">1</span>, dim, device<span class="op">=</span>trajs.device),</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                            trajs_norm], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> trajs_norm, std</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can proceed to process the trajectories. In the following piece of code, we process every trajectory (outer loop). Then, we split it into segments with constant properties (inner loop), and we compute the mean absolute error (MAE) and the mean relative error with the three aforementioned approaches.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>max_samples <span class="op">=</span> <span class="dv">50000</span> <span class="co"># Subsample 50k trajectories</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>segment_data <span class="op">=</span> []</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> tqdm(ds[:max_samples].iterrows()):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    x, y <span class="op">=</span> row.x, row.y_exp.squeeze()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    y_mod, cps <span class="op">=</span> row.y_mod.squeeze(), row.cp</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Predict over full trajectory</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    pred <span class="op">=</span> predict_norm_sample(learn_exp.model, x.T)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Segment trajectory with true changepoints</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    split_x, split_pred <span class="op">=</span> split_tensor(x.T, cps), split_tensor(pred, cps)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    split_y, split_model <span class="op">=</span> split_tensor(y, cps), split_tensor(y_mod, cps)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    splits <span class="op">=</span> <span class="bu">zip</span>(split_x, split_y, split_model, split_pred)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j, (seg_x, seg_y, seg_model, pred_cut) <span class="kw">in</span> <span class="bu">enumerate</span>(splits):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Prediction over full trajectory cut with true changepoints</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        mae <span class="op">=</span> mean_absolute_error(pred_cut, seg_y)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Add noise to flat CTRW segments for numerical stability</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (seg_x <span class="op">-</span> seg_x[<span class="dv">0</span>]).allclose(tensor(<span class="fl">0.</span>)):</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            seg_x <span class="op">+=</span> <span class="fl">0.1</span><span class="op">*</span>torch.randn_like(seg_x)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Prediction over segment</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        pred_segment <span class="op">=</span> predict_norm_sample(learn_exp.model, seg_x <span class="op">-</span> seg_x[<span class="dv">0</span>])</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        mae_segment <span class="op">=</span> mean_absolute_error(pred_segment, seg_y)</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Prediction over segment with TA-MSD</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        pred_tamsd <span class="op">=</span> anomalous_exponent_tamsd(seg_x)</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        mae_tamsd <span class="op">=</span> mean_absolute_error(pred_tamsd, seg_y[<span class="dv">0</span>])</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        segment_data.append({<span class="st">'sample'</span>: i, <span class="st">'segment_idx'</span>: j,</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'length'</span>: <span class="bu">len</span>(seg_y), <span class="st">'x'</span>: seg_x, <span class="st">'y'</span>: seg_y,</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'model'</span>: seg_model[<span class="dv">0</span>], <span class="st">'pred_cut'</span>: pred_cut, </span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'pred_segment'</span>: pred_segment,</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'pred_tamsd'</span>: pred_tamsd, <span class="st">'mae'</span>: mae,</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'mae_segment'</span>: mae_segment,</span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>                             <span class="st">'mae_tamsd'</span>: mae_tamsd})</span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> pd.DataFrame.from_records(segment_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Unlike in the normal diffusion case, we encounter some numerical instabilities with the methods when we provide them with the split segments. We purge all the broken predictions to proceed with the analysis.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>mask_full <span class="op">=</span> ds.mae.<span class="bu">apply</span>(<span class="kw">lambda</span> x: torch.isnan(x).item())</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>mask_tamsd <span class="op">=</span> ds.mae_tamsd.<span class="bu">apply</span>(<span class="kw">lambda</span> x: torch.isnan(x).item())</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>mask_seg <span class="op">=</span> ds.mae_segment.<span class="bu">apply</span>(<span class="kw">lambda</span> x: torch.isnan(x).item())</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>mask <span class="op">=</span> (mask_full <span class="op">|</span> mask_tamsd <span class="op">|</span> mask_seg)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ds[<span class="op">~</span>mask]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can save all the data for further posterior processing.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>ds.to_pickle(DATA_PATH<span class="op">/</span><span class="st">'segment_analysis_alpha_test.pkl'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="prediction-error" class="level2">
<h2 class="anchored" data-anchor-id="prediction-error">Prediction error</h2>
<p>Let’s quantify the model performances by computing their MAE over full trajectories and trajectory segments.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>lengths <span class="op">=</span> ds.length.unique().astype(<span class="bu">int</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>lengths.sort()</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>metrics <span class="op">=</span> [<span class="st">'mae'</span>, <span class="st">'mae_segment'</span>, <span class="st">'mae_tamsd'</span>]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>metric_by_length <span class="op">=</span> {m: {<span class="st">'mean'</span>: [], <span class="st">'sem'</span>: [], <span class="st">'global'</span>: <span class="va">None</span>}</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> m <span class="kw">in</span> metrics}</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m <span class="kw">in</span> metrics:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    means <span class="op">=</span> [<span class="bu">getattr</span>(ds, m)[ds.length <span class="op">==</span> l].mean()</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>             <span class="cf">for</span> l <span class="kw">in</span> lengths]</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    sems <span class="op">=</span> [<span class="bu">getattr</span>(ds, m)[ds.length <span class="op">==</span> l].sem()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> l <span class="kw">in</span> lengths]</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    metric_by_length[m][<span class="st">'mean'</span>] <span class="op">=</span> np.array(means)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    metric_by_length[m][<span class="st">'sem'</span>] <span class="op">=</span> np.array(sems)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    metric_by_length[m][<span class="st">'global'</span>] <span class="op">=</span> (</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        (<span class="bu">getattr</span>(ds, m)<span class="op">*</span>ds.length).<span class="bu">sum</span>() <span class="op">/</span> </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        ds.length.<span class="bu">sum</span>()</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Save this for later.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>name <span class="op">=</span> <span class="st">"mae_segment_length"</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>data_path <span class="op">=</span> (FIG_PATH<span class="op">/</span>name).with_suffix(<span class="st">".pkl"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(data_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    pickle.dump(metric_by_length, f, protocol<span class="op">=</span>pickle.HIGHEST_PROTOCOL)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see the overall MAE for each method.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"STEP: </span><span class="sc">{</span>metric_by_length[<span class="st">'mae'</span>][<span class="st">'global'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"STEP + segments: </span><span class="sc">{</span>metric_by_length[<span class="st">'mae_segment'</span>][<span class="st">'global'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"TA-MSD + segments: </span><span class="sc">{</span>metric_by_length[<span class="st">'mae_tmsd'</span>][<span class="st">'global'</span>]<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>STEP: 0.271
STEP + segments: 0.275
TA-MSD + segments: 0.368</code></pre>
</div>
</div>
<p>STEP outperforms the TA-MSD baseline, reducing the overall error by more than <span class="math inline">\(25\%\)</span>. The advantage is significantly larger in short segments, as we see below.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="fl">1.5</span><span class="op">*</span>fig_size, fig_size))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>lengths <span class="op">=</span> np.arange(<span class="dv">10</span>, <span class="dv">191</span>)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">'STEP'</span>, <span class="st">'STEP + segments'</span>, <span class="st">'TA-MSD + segments'</span>]</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, m <span class="kw">in</span> <span class="bu">enumerate</span>(metric_by_length.keys()):</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    mean, sem <span class="op">=</span> metric_by_length[m][<span class="st">'mean'</span>], metric_by_length[m][<span class="st">'sem'</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    label <span class="op">=</span> labels[i<span class="op">//</span><span class="dv">2</span>]<span class="co"># if i%2 == 0 else None</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    plt.plot(lengths, mean, linestyle<span class="op">=</span><span class="st">'-'</span>, color<span class="op">=</span>colors[i<span class="op">//</span><span class="dv">2</span>], label<span class="op">=</span>label,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>                    zorder<span class="op">=</span><span class="dv">10</span> <span class="cf">if</span> i<span class="op">==</span><span class="dv">0</span> <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    plt.fill_between(lengths, mean <span class="op">-</span> sem, mean <span class="op">+</span> sem, color<span class="op">=</span>colors[i<span class="op">//</span><span class="dv">2</span>], alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span>alpha_grid)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">11</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>plt.tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="fl">0.1</span>, <span class="fl">0.75</span>])</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Segment length"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r"$|\alpha_</span><span class="sc">{true}</span><span class="vs"> - \alpha_</span><span class="sc">{pred}</span><span class="vs">|$"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-13-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In this case, the TA-MSD-based method does never reach the performance level of STEP, even in very long segments. This is in contrast to the <a href="https://borjarequena.github.io/step/tutorials/analysis_bm.html#prediction-error">Brownian motion benchmark</a>, where the TA-MSD method attains a similar performance for the longest segments.</p>
<p>Additionally, in this case, feeding STEP with segments harms the performance in the shortest segments. As we have mentioned previously, doing this causes some numerical issues with the methods (both STEP and the TA-MSD). Regardless, the pre-segmented trajectories are never available in real scenarios.</p>
</section>
<section id="error-by-anomalous-diffusion-model" class="level2">
<h2 class="anchored" data-anchor-id="error-by-anomalous-diffusion-model">Error by anomalous diffusion model</h2>
<p>The anomalous diffusion models that we consider describe very different behaviours. The deviation from normal diffusion has different sources in each of them and, therefore, their anomalous diffusion exponent <span class="math inline">\(\alpha\)</span> depends on different phenomena.</p>
<p>Hence, it is reasonable to expect the underlying anomalous diffusion model of each segment to play a key role in the characterization. Furthermore, every model has a different range for <span class="math inline">\(\alpha\)</span>:</p>
<ul>
<li>Annealed transit time (ATTM) with <span class="math inline">\(\alpha\in\left[0.05, 1\right]\)</span>.</li>
<li>Continuous time random walk (CTRW) with <span class="math inline">\(\alpha\in\left[0.05, 1\right]\)</span>.</li>
<li>Fractional Brownian motion (FBM) with <span class="math inline">\(\alpha\in\left[0.05, 1.95\right]\)</span>.</li>
<li>Lévy Walk (LW) with <span class="math inline">\(\alpha\in\left[1.05, 2\right]\)</span>.</li>
<li>Scaled Brownian motion (SBM) with <span class="math inline">\(\alpha\in\left[0.05, 2\right]\)</span>.</li>
</ul>
<p>The wider the <span class="math inline">\(\alpha\)</span> range, the larger the errors can become. Let’s look at the MAE for each method.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>mae_by_model <span class="op">=</span> [ds[(ds.model <span class="op">==</span> m)].mae.mean()</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> m <span class="kw">in</span> MODEL_DATA.keys()]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.arange(<span class="dv">5</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>plt.bar(x, mae_by_model, color<span class="op">=</span>colors[<span class="dv">0</span>], width<span class="op">=</span><span class="fl">0.6</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>plt.grid(axis<span class="op">=</span><span class="st">'y'</span>, alpha<span class="op">=</span>alpha_grid)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'MAE'</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>plt.xticks(x, [MODEL_DATA[n][<span class="st">'name'</span>].upper() <span class="cf">for</span> n <span class="kw">in</span> x])</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>plt.tick_params(axis<span class="op">=</span><span class="st">'x'</span>, labelsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>plt.tick_params(axis<span class="op">=</span><span class="st">'y'</span>, labelsize<span class="op">=</span><span class="dv">14</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-15-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>CTRW, FBM and LW have similar MAE. Surprisingly, FBM holds the lowest error while having one of the largest ranges for <span class="math inline">\(\alpha\)</span>. Then, ATTM and SBM are clearly the hardest models to characterize, as their MAE is between <span class="math inline">\(50\%\)</span> to <span class="math inline">\(100\%\)</span> larger than the other methods.</p>
<p>In SBM, as we will see in the next tutorial, <span class="math inline">\(\alpha\)</span> is related to the ageing of the diffusion coefficient. This means that we need long segments to correctly characterize <span class="math inline">\(\alpha\)</span>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>SBM was also found to be the hardest model to characterize in the <a href="https://www.nature.com/articles/s41467-021-26320-w">AnDi Challenge</a>.</p>
</div>
</div>
<p>Let’s bring this study further to get a better idea about the sources of errors in all the models, such as ATTM.</p>
</section>
<section id="error-by-diffusion-model-and-localization-noise" class="level2">
<h2 class="anchored" data-anchor-id="error-by-diffusion-model-and-localization-noise">Error by diffusion model and localization noise</h2>
<p>Let’s study the behaviour of STEP for each diffusion model in more detail and, at the same time, study its resilience to localization noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Optional: load the test set if it is not in memory</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> load_dataset(n_change<span class="op">=</span><span class="st">"1_to_4"</span>, dim<span class="op">=</span>dim, name<span class="op">=</span><span class="st">"test"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To make the computation more bearable, we work with a fraction of our full test set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ds.sample(frac<span class="op">=</span><span class="fl">0.25</span>, random_state<span class="op">=</span><span class="dv">0</span>).reset_index(drop<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>ds[<span class="st">'y'</span>] <span class="op">=</span> ds[<span class="st">'y_exp'</span>].<span class="bu">apply</span>(torch.squeeze)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>ds[<span class="st">'model'</span>] <span class="op">=</span> ds[<span class="st">'y_mod'</span>].<span class="bu">apply</span>(torch.squeeze)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ds.drop(columns<span class="op">=</span>[<span class="st">'y_mod'</span>, <span class="st">'y_exp'</span>, <span class="st">'models'</span>, <span class="st">'exps'</span>, <span class="st">'noise'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="process-the-trajectories" class="level3">
<h3 class="anchored" data-anchor-id="process-the-trajectories">Process the trajectories</h3>
<p>Similar to the <a href="https://borjarequena.github.io/step/tutorials/analysis_bm.html#resilience-to-noise">Brownian motion analysis</a>, we will process the trajectories at various noise levels.</p>
<p>Here, we sample <span class="math inline">\(\sigma_{\text{noise}}\in[10^{-5}, 10^2]\)</span> uniformly in log space.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>noise_samples <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>noise_max, noise_min <span class="op">=</span> <span class="dv">2</span>, <span class="op">-</span><span class="dv">5</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>noise_range <span class="op">=</span> noise_max <span class="op">-</span> noise_min</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>noise_traj <span class="op">=</span> torch.rand(ds.shape[<span class="dv">0</span>], noise_samples)<span class="op">*</span>noise_range <span class="op">+</span> noise_min</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As in the previous cases, we can compare the predictions of STEP with the TA-MSD baseline.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict(model, x):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Get prediction of `model` on batch `x`."</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> to_detach(model(x.to(default_device()))).squeeze()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>shape <span class="op">=</span> (ds.shape[<span class="dv">0</span>], max_t, noise_traj.shape[<span class="dv">1</span>])</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>pred_by_noise <span class="op">=</span> torch.zeros(shape) </span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>pred_tamsd_by_noise <span class="op">=</span> torch.zeros(shape)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (x, cps) <span class="kw">in</span> tqdm(ds[[<span class="st">'x'</span>,<span class="st">'cp'</span>]].iterrows()):</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    noise <span class="op">=</span> torch.randn(noise_samples, <span class="op">*</span>x.T.shape)<span class="op">*</span><span class="dv">10</span><span class="op">**</span>noise_traj[i]</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>    noisy_x <span class="op">=</span> x.T.unsqueeze(<span class="dv">0</span>) <span class="op">+</span> noise.unsqueeze(<span class="op">-</span><span class="dv">1</span>).unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>    noisy_x, std <span class="op">=</span> normalize(noisy_x)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a>    split_x <span class="op">=</span> split_tensor(noisy_x.transpose(<span class="dv">1</span>, <span class="dv">0</span>), cps)</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>    pred_by_noise[i] <span class="op">=</span> predict(learn_exp.model, noisy_x).T</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    pred_tamsd <span class="op">=</span> []</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> seg_x <span class="kw">in</span> split_x:</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>        seg_x, _ <span class="op">=</span> normalize(seg_x.transpose(<span class="dv">1</span>, <span class="dv">0</span>))</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        ones <span class="op">=</span> torch.ones(seg_x.shape[<span class="dv">1</span>])</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>        pred_tamsd.append(torch.stack([ones<span class="op">*</span>anomalous_exponent_tamsd(s)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>                                       <span class="cf">for</span> s <span class="kw">in</span> seg_x]))</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a>    pred_tamsd_by_noise[i] <span class="op">=</span> torch.cat(pred_tamsd, axis<span class="op">=-</span><span class="dv">1</span>).T</span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>([<span class="st">'full'</span>, <span class="st">'tamsd'</span>],</span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>                       [pred_by_noise, pred_tamsd_by_noise]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With the predictions, we can compute the error performed at every time step as a function of <span class="math inline">\(\sigma_{\text{noise}}\)</span> and the diffusion model independently.</p>
<p>Therefore, we start by obtaining the diffusion model and noise of every trajectory at every time step.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> torch.stack([t <span class="cf">for</span> t <span class="kw">in</span> ds[<span class="st">'y'</span>].values])</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> torch.stack([t <span class="cf">for</span> t <span class="kw">in</span> ds[<span class="st">'model'</span>].values])</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>rel_noise <span class="op">=</span> noise_traj.unsqueeze(<span class="dv">1</span>) <span class="op">+</span> torch.zeros_like(y.unsqueeze(<span class="op">-</span><span class="dv">1</span>)) </span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> model.unsqueeze(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> torch.zeros_like(rel_noise)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can compute the pointwise errors of the full test set with random noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>errors <span class="op">=</span> {k: y.unsqueeze(<span class="op">-</span><span class="dv">1</span>) <span class="op">-</span> p <span class="cf">for</span> k, p <span class="kw">in</span> predictions.items()}</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>bins_noise <span class="op">=</span> torch.linspace(rel_noise.<span class="bu">min</span>(), rel_noise.<span class="bu">max</span>(), <span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="overall-performance" class="level3">
<h3 class="anchored" data-anchor-id="overall-performance">Overall performance</h3>
<p>We can get a good idea about the error sources by looking at the predicted vs true <span class="math inline">\(\alpha\)</span> values for each anomalous diffusion model.</p>
<p>For this, we need a target tensor with the same shape as our predictions for all noise levels.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>y_ext <span class="op">=</span> y.unsqueeze(<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> torch.zeros_like(model)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>y_ext.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>torch.Size([49994, 200, 128])</code></pre>
</div>
</div>
<p>And it is useful to have a mapping between model names and their integer index.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>model_keys <span class="op">=</span> {v[<span class="st">'name'</span>]: k <span class="cf">for</span> k, v <span class="kw">in</span> MODEL_DATA.items()}</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>model_keys</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<pre><code>{'attm': 0, 'ctrw': 1, 'fbm': 2, 'lw': 3, 'sbm': 4}</code></pre>
</div>
</div>
<p>Now we can define the different noise intervals at which we wish to study the models. We consider <span class="math inline">\(\sigma_{\text{noise}}\in\left\{[10^{-5}, 10^{-4}], [10^{-2}, 10^{-1}], [10^{-1}, 10^{0}]\right\}\)</span>. The first interval is a quasy-noiseless regime, the second is moderate noise and the third is very high noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>pred_vs_true_by_model <span class="op">=</span> {}</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>noise_ranges <span class="op">=</span> [(<span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="dv">4</span>), (<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)]</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>bins <span class="op">=</span> (<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">41</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s compute the 2D histograms of <span class="math inline">\(\alpha_{\text{pred}}\)</span> vs <span class="math inline">\(\alpha_{\text{true}}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>preds_full <span class="op">=</span> predictions[<span class="st">'full'</span>]</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m <span class="kw">in</span> tqdm(<span class="bu">list</span>(model_keys.keys()) <span class="op">+</span> [<span class="st">'all'</span>]):</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    mask_model <span class="op">=</span> (model <span class="op">==</span> model_keys[m] <span class="cf">if</span> m <span class="op">!=</span> <span class="st">'all'</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>                  <span class="cf">else</span> torch.ones_like(model, dtype<span class="op">=</span><span class="bu">bool</span>))</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>    model_histograms <span class="op">=</span> []</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (low, high) <span class="kw">in</span> noise_ranges:</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>        mask_noise <span class="op">=</span> (low <span class="op">&lt;=</span> rel_noise) <span class="op">&amp;</span> (rel_noise <span class="op">&lt;</span> high)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> mask_model <span class="op">&amp;</span> mask_noise</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a>        hist, true_e, pred_e <span class="op">=</span> np.histogram2d(y_ext[mask].numpy(),</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>                                              preds_full[mask].numpy(),</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>                                              bins<span class="op">=</span>[np.linspace(<span class="op">*</span>bins)<span class="op">+</span><span class="fl">1e-3</span>,</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>                                              np.linspace(<span class="op">*</span>bins[:<span class="dv">2</span>], <span class="dv">41</span>)])</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        model_histograms.append(hist)</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>    pred_vs_true_by_model[m] <span class="op">=</span> {<span class="st">'hist'</span>: model_histograms,</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a>                                <span class="st">'true_edges'</span>: true_e, </span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a>                                <span class="st">'pred_edges'</span>: pred_e}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"163cc261ac29420690cb1e14bc074fb1","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>Save them for later.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>fig_name <span class="op">=</span> <span class="st">"pred_vs_true_models"</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>plot_data <span class="op">=</span> (pred_vs_true_by_model, noise_ranges, bins_by_model)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(FIG_PATH<span class="op">/</span><span class="ss">f'</span><span class="sc">{</span>fig_name<span class="sc">}</span><span class="ss">.pkl'</span>, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    pickle.dump(plot_data, f, protocol<span class="op">=</span>pickle.HIGHEST_PROTOCOL)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">5</span>, figsize<span class="op">=</span>(<span class="dv">6</span><span class="op">*</span>fig_size, <span class="dv">3</span><span class="op">*</span>fig_size),</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                         constrained_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>ticks <span class="op">=</span> (np.arange(<span class="dv">0</span>, <span class="dv">41</span>, <span class="dv">20</span>), [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>ticksize <span class="op">=</span> <span class="dv">16</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>fontsize <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>noise_ranges <span class="op">=</span> [<span class="st">"$[10^{-5}, 10^{-4})$"</span>,</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>                <span class="st">"$[10^{-2}, 10^{-1})$"</span>,</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>                <span class="st">"$[10^{-1}, 10^</span><span class="sc">{0}</span><span class="st">)$"</span>]</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>vmax <span class="op">=</span> {<span class="st">'attm'</span>: [<span class="fl">0.9</span>, <span class="fl">0.9</span>, <span class="fl">0.9</span>],</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">'ctrw'</span>: [<span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.8</span>],</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">'fbm'</span>:  [<span class="fl">0.3</span>, <span class="fl">0.3</span>, <span class="fl">0.5</span>],</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">'lw'</span>:   [<span class="fl">0.6</span>, <span class="fl">0.6</span>, <span class="fl">0.6</span>],</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">'sbm'</span>:  [<span class="fl">0.9</span>, <span class="fl">0.9</span>, <span class="dv">1</span>]}</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, data <span class="kw">in</span> pred_vs_true_by_model.items():</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="st">'all'</span>: <span class="cf">continue</span></span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>    m_axes <span class="op">=</span> axes[:, model_keys[m]]</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>    hist<span class="op">=</span> data[<span class="st">'hist'</span>]</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, ax <span class="kw">in</span> <span class="bu">enumerate</span>(m_axes):</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>        shape <span class="op">=</span> hist[i].shape</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>        ax.pcolor(hist[i].T<span class="op">/</span>hist[i].<span class="bu">max</span>(), vmin<span class="op">=</span><span class="dv">0</span>, vmax<span class="op">=</span>vmax[m][i],</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>                  cmap<span class="op">=</span>cmap_hist1, rasterized<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>            ax.set_title(m.upper(), fontsize<span class="op">=</span>fontsize)</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>            ax.tick_params(labeltop<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>            ax.tick_params(labeltop<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb31-29"><a href="#cb31-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb31-30"><a href="#cb31-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb31-31"><a href="#cb31-31" aria-hidden="true" tabindex="-1"></a>            ax.set_xticks(<span class="op">*</span>ticks)</span>
<span id="cb31-32"><a href="#cb31-32" aria-hidden="true" tabindex="-1"></a>            ax.set_xlabel(<span class="vs">r'$\alpha_</span><span class="sc">{true}</span><span class="vs">$'</span>, fontsize<span class="op">=</span>fontsize)</span>
<span id="cb31-33"><a href="#cb31-33" aria-hidden="true" tabindex="-1"></a>            ax.tick_params(labeltop<span class="op">=</span><span class="va">False</span>, labelbottom<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb31-34"><a href="#cb31-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb31-35"><a href="#cb31-35" aria-hidden="true" tabindex="-1"></a>            ax.set_xticks([])</span>
<span id="cb31-36"><a href="#cb31-36" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb31-37"><a href="#cb31-37" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> model_keys[m] <span class="op">==</span> <span class="dv">0</span>: </span>
<span id="cb31-38"><a href="#cb31-38" aria-hidden="true" tabindex="-1"></a>            ax.set_ylabel(<span class="vs">r'$\alpha_</span><span class="sc">{pred}</span><span class="vs">$'</span>, fontsize<span class="op">=</span>fontsize)</span>
<span id="cb31-39"><a href="#cb31-39" aria-hidden="true" tabindex="-1"></a>            ax.set_yticks(<span class="op">*</span>ticks)</span>
<span id="cb31-40"><a href="#cb31-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb31-41"><a href="#cb31-41" aria-hidden="true" tabindex="-1"></a>            ax.set_yticks([])</span>
<span id="cb31-42"><a href="#cb31-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb31-43"><a href="#cb31-43" aria-hidden="true" tabindex="-1"></a>        ax.tick_params(labelsize<span class="op">=</span>ticksize)<span class="op">;</span></span>
<span id="cb31-44"><a href="#cb31-44" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb31-45"><a href="#cb31-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="st">'sbm'</span>:</span>
<span id="cb31-46"><a href="#cb31-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ax, noise <span class="kw">in</span> <span class="bu">zip</span>(m_axes, noise_ranges):</span>
<span id="cb31-47"><a href="#cb31-47" aria-hidden="true" tabindex="-1"></a>            ax.text(<span class="dv">42</span>, <span class="dv">20</span>, <span class="vs">fr"$\sigma_</span><span class="ch">{{</span><span class="vs">noise</span><span class="ch">}}</span><span class="vs"> \in$"</span> <span class="op">+</span> noise, fontsize<span class="op">=</span>fontsize)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-29-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>As expected, we observe a very nice <span class="math inline">\(\alpha_{\text{pred}}\)</span> vs <span class="math inline">\(\alpha_{\text{true}}\)</span> relationship for FBM and LW segments.</p>
<p>There is a clear tendency for STEP to predict <span class="math inline">\(\alpha\approx0.8\)</span> for SBM segments which is enhanced with noise. This is indicative that the model struggles to identify any clear behaviour and defaults to a quasi Brownian motion prediction.</p>
<p>In CTRW segments we find a similar pattern, where the model predicts <span class="math inline">\(\alpha\approx0.25\)</span>, corresponding to nearly immobile particles. CTRW trajectories are characterized by immobilization with jumps at random times. In short segments, it is very likely that no jumps are shown and, thus, the model sees a static particle.</p>
<p>To a lesser extent, we observe a tendnency for ATTM trajectories to predict <span class="math inline">\(\alpha\approx1\)</span>. ATTM trajectories are characterized by Brownian motion segments with random diffusion coefficients that change at random times. In short ATTM segments, it is very likely that there are no diffusion coefficient changes. Therefore, STEP only sees a pure Brownian motion segment for which the prediction of <span class="math inline">\(\alpha\approx1\)</span> is correct.</p>
</section>
<section id="mae-as-function-of-sigma_textnoise" class="level3">
<h3 class="anchored" data-anchor-id="mae-as-function-of-sigma_textnoise">MAE as function of <span class="math inline">\(\sigma_{\text{noise}}\)</span></h3>
<p>Now we can look at the MAE of STEP and the TA-MSD baseline as function of the localization noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>noise_err, noise_err_std, x_err, counts <span class="op">=</span> [], [], [], []</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> low, high <span class="kw">in</span> tqdm(<span class="bu">zip</span>(bins_noise[:<span class="op">-</span><span class="dv">1</span>], bins_noise[<span class="dv">1</span>:])):</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> (rel_noise <span class="op">&gt;=</span> low) <span class="op">&amp;</span> (rel_noise <span class="op">&lt;=</span> high)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    x.append((low <span class="op">+</span> high)<span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    counts.append(mask.<span class="bu">float</span>().<span class="bu">sum</span>())</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    noise_err.append(tensor([err[mask <span class="op">&amp;</span> <span class="op">~</span>err.isnan()].<span class="bu">abs</span>().mean()</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>                             <span class="cf">for</span> err <span class="kw">in</span> errors.values()]))</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    noise_err_std.append(tensor([err[mask <span class="op">&amp;</span> <span class="op">~</span>err.isnan()].<span class="bu">abs</span>().std()</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>                                 <span class="cf">for</span> err <span class="kw">in</span> errors.values()]))</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>noise_err <span class="op">=</span> torch.stack(noise_err)</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>noise_err_std <span class="op">=</span> torch.stack(noise_err_std)</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>x_err <span class="op">=</span> torch.stack(x_err)</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>counts <span class="op">=</span> torch.stack(counts)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"701924c8b3e34fdba46f4f628318a9a5","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<p>We can go a step further and compute the MAE for each diffusion model separately and as function of the noise.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>errors_model <span class="op">=</span> {k: errors[<span class="st">'full'</span>][model <span class="op">==</span> i] <span class="cf">for</span> k, i <span class="kw">in</span> model_keys.items()}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>mae_model_by_noise <span class="op">=</span> {}</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, i <span class="kw">in</span> model_keys.items():</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    mae <span class="op">=</span> []</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    noise_model <span class="op">=</span> rel_noise[model <span class="op">==</span> i]</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> low, high <span class="kw">in</span> tqdm(<span class="bu">zip</span>(bins_noise[:<span class="op">-</span><span class="dv">1</span>], bins_noise[<span class="dv">1</span>:])):</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>        mask <span class="op">=</span> (noise_model <span class="op">&gt;=</span> low) <span class="op">&amp;</span> (noise_model <span class="op">&lt;=</span> high)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>        mae.append(errors_model[m][mask].<span class="bu">abs</span>().mean())</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>    mae_model_by_noise[m] <span class="op">=</span> mae</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"8e54370f80be4bef894c1d871e2b45b8","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"11fdc03d7bbd4d57b87c1433460474d6","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"f1907d589bdc48cbb0879f5ffa3c42d1","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"2588a79ecc964b459083d906f7772daf","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"d818bf6b9fc84421bc3b6736f0fd3ac2","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>fig, ax <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">2</span>, figsize<span class="op">=</span>(<span class="fl">2.5</span><span class="op">*</span>fig_size, fig_size), constrained_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> [<span class="st">'STEP'</span>, <span class="st">'TA-MSD + segments'</span>]</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>idx <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">3</span>]</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>sem <span class="op">=</span> noise_err_std<span class="op">/</span>counts.sqrt().unsqueeze(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (err, s) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(noise_err.T[idx], sem.T[idx])):</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].semilogx(<span class="dv">10</span><span class="op">**</span>x_err, err, <span class="st">'-'</span>, linewidth<span class="op">=</span><span class="fl">3.</span>, color<span class="op">=</span>colors[<span class="dv">2</span><span class="op">*</span>i], label<span class="op">=</span>labels[i])</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">0</span>].fill_between(<span class="dv">10</span><span class="op">**</span>x_err, err <span class="op">-</span> s, err <span class="op">+</span> s, color<span class="op">=</span>colors[<span class="dv">2</span><span class="op">*</span>i], alpha<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].legend(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlabel(<span class="vs">r"$\sigma_</span><span class="sc">{noise}</span><span class="vs">$"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_ylabel(<span class="st">"MAE"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">0</span>].set_xlim([<span class="fl">2e-5</span>, <span class="dv">50</span>])</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> bins_noise[<span class="dv">1</span>] <span class="op">-</span> bins_noise[<span class="dv">0</span>]</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>x_noise_model <span class="op">=</span> bins_noise[:<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dx</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, (m, mae) <span class="kw">in</span> <span class="bu">enumerate</span>(mae_model_by_noise.items()):</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    ax[<span class="dv">1</span>].semilogx(<span class="dv">10</span><span class="op">**</span>x_noise_model, mae, linewidth<span class="op">=</span><span class="dv">2</span>, color<span class="op">=</span>colors[i], label<span class="op">=</span>m.upper())</span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlim([<span class="dv">10</span><span class="op">**</span>(<span class="op">-</span><span class="fl">3.5</span>), <span class="dv">6</span>])</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].legend(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_xlabel(<span class="vs">r"$\sigma_</span><span class="sc">{noise}</span><span class="vs">$"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>ax[<span class="dv">1</span>].set_yticklabels([])</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a <span class="kw">in</span> ax:</span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a>    a.tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    a.grid(alpha<span class="op">=</span>alpha_grid)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-33-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Let’s save the data of the figures to process them later.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>fig_name <span class="op">=</span> <span class="st">"noise_analysis_alpha"</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>plot_path <span class="op">=</span> (FIG_PATH<span class="op">/</span>fig_name).with_suffix(<span class="st">".pkl"</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>plot_data <span class="op">=</span> (noise_err, noise_err_std, x, counts)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(plot_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    pickle.dump(plot_data, f, protocol<span class="op">=</span>pickle.HIGHEST_PROTOCOL)</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>fig_name <span class="op">=</span> <span class="st">"noise_analysis_mae_models"</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>plot_path <span class="op">=</span> (FIG_PATH<span class="op">/</span>fig_name).with_suffix(<span class="st">".pkl"</span>)</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>plot_data <span class="op">=</span> (mae_model_by_noise, bins_noise)</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(plot_path, <span class="st">'wb'</span>) <span class="im">as</span> f:</span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a>    pickle.dump(plot_data, f, protocol<span class="op">=</span>pickle.HIGHEST_PROTOCOL)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="changepoint-detection" class="level1">
<h1>Changepoint detection</h1>
<p>In the <a href="https://borjarequena.github.io/step/tutorials/analysis_bm.html#changepoint-detection">Brownian motion benchmark</a>, we show a few ways to detect the position at which the trajectory behaviour changes. Here, we perform an analogous analysis to detect changes in the anomalous diffusion exponent <span class="math inline">\(\alpha\)</span>.</p>
<p>We compare the results obtained by feeding the STEP predictions to the kernel changepoint detection algorithm provided by <a href="https://centre-borelli.github.io/ruptures-docs/">ruptures</a>, with running ruptures on top of an <span class="math inline">\(\alpha\)</span> estimation with the TA-MSD over a sliding window along the trajectory.</p>
<section id="generate-the-data-1" class="level2">
<h2 class="anchored" data-anchor-id="generate-the-data-1">Generate the data</h2>
<p>In order to obtain a better insight about the strengths of the methods, we test them in trajectories with one single changepoint. Furthermore, we restrict ourselves to FBM trajectories, which has been the anomalous diffusion model for which our methods provided the best results.</p>
<p>In this way, we study how the changepoint position and difference between <span class="math inline">\(\alpha\)</span> in consecutive segments affects the performance.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> create_segmentation_dataset(<span class="dv">40000</span>, dim<span class="op">=</span><span class="dv">2</span>, models<span class="op">=</span>[<span class="dv">2</span>], noise<span class="op">=</span>[<span class="fl">0.</span>], save<span class="op">=</span><span class="va">False</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="get-the-predictions-1" class="level2">
<h2 class="anchored" data-anchor-id="get-the-predictions-1">Get the predictions</h2>
<p>Let’s define some helping functions to keep our code clean.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_batch(df, i, bs, col<span class="op">=</span><span class="st">'x'</span>):</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Return a batch of samples from df."</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    samples <span class="op">=</span> [x.transpose(<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>) <span class="cf">for</span> x <span class="kw">in</span> ds.loc[i<span class="op">*</span>bs:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>bs<span class="op">-</span><span class="dv">1</span>, col]]</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> torch.stack(samples, dim<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> predict_norm(model, x):</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Get the `model` prediction normalizing the batch `x`."</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    x_norm <span class="op">=</span> normalize(x.to(default_device()))[<span class="dv">0</span>]</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> to_detach(model(x_norm).squeeze())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s gooo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>bs <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>n_batch <span class="op">=</span> np.ceil(ds.shape[<span class="dv">0</span>]<span class="op">/</span>bs).astype(<span class="bu">int</span>)</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> tqdm(<span class="bu">range</span>(n_batch)):</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    xb <span class="op">=</span> make_batch(ds, i, bs)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    pred <span class="op">=</span> predict_norm(learn_exp.model, xb)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    ds.loc[i<span class="op">*</span>bs:(i<span class="op">+</span><span class="dv">1</span>)<span class="op">*</span>bs<span class="op">-</span><span class="dv">1</span>, <span class="st">'pred'</span>] <span class="op">=</span> np.array([p <span class="cf">for</span> p <span class="kw">in</span> pred],</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>                                               dtype<span class="op">=</span><span class="bu">object</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"81cf100d3cb9434c9a731e111074b664","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
</section>
<section id="overall-performance-1" class="level2">
<h2 class="anchored" data-anchor-id="overall-performance-1">Overall performance</h2>
<p>Let’s compute the Jaccard index (JI) using the STEP predictions and the <span class="math inline">\(\alpha\)</span> estimation with the TA-MSD.</p>
<p>We need to define a function to compute <span class="math inline">\(\alpha\)</span> along the trajectory with a sliding window.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> swin_alpha_tamsd(x, win_size<span class="op">=</span><span class="dv">10</span>):</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Computes the anomalous exponent with a sliding window over x."</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    alphas <span class="op">=</span> []</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(x) <span class="op">-</span> win_size):</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> anomalous_exponent_tamsd(x[i:i <span class="op">+</span> win_size],</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>                                         t_lag<span class="op">=</span>np.arange(<span class="dv">2</span>, win_size<span class="op">//</span><span class="dv">2</span>))</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        alphas.append(alpha)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.array(alphas)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To ease the code readability, we define a function to combine two dictionaries together (adhoc for our purposes).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> merge_dict(dict_1, dict_2):</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>    merge <span class="op">=</span> {}</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> k, v1 <span class="kw">in</span> dict_1.items():</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>        v2 <span class="op">=</span> dict_2.get(k, [])</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">isinstance</span>(v1, Iterable) <span class="kw">and</span> <span class="bu">isinstance</span>(v2, Iterable):</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>            merge[k] <span class="op">=</span> [<span class="op">*</span>v1, <span class="op">*</span>v2]</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(v1, Iterable):</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>            merge[k] <span class="op">=</span> [<span class="op">*</span>v1, v2]</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="bu">isinstance</span>(v2, Iterable):</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>            merge[k] <span class="op">=</span> [v1, <span class="op">*</span>v2]</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>            merge[k] <span class="op">=</span> [v1, v2]</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> merge</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we process every trajectory and retrieve the changepoints with ruptures using both inputs.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>method_pen <span class="op">=</span> {<span class="st">'pred'</span>: <span class="fl">2.</span>, <span class="st">'tamsd'</span>: <span class="fl">8.</span>}</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>win_size <span class="op">=</span> <span class="dv">30</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>methods <span class="op">=</span> <span class="bu">list</span>(method_pen.keys())</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>threshold <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>metrics_method <span class="op">=</span> {m: {} <span class="cf">for</span> m <span class="kw">in</span> methods}</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, row <span class="kw">in</span> tqdm(ds.iterrows()):</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>    traj <span class="op">=</span> normalize(row.x.T.unsqueeze(<span class="dv">0</span>))[<span class="dv">0</span>]</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    pred, true_cp <span class="op">=</span> row.pred.numpy(), row.cp.numpy()</span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>    alphas_tamsd <span class="op">=</span> swin_alpha_tamsd(traj.squeeze(), win_size<span class="op">=</span>win_size)</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="kw">in</span> methods:</span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a>        seg_data <span class="op">=</span> (pred <span class="cf">if</span> m <span class="op">==</span> <span class="st">'pred'</span> </span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span> alphas_tamsd <span class="cf">if</span> m <span class="op">==</span> <span class="st">'tamsd'</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span> <span class="va">None</span>)</span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a>        pred_cp <span class="op">=</span> ruptures_cp(seg_data, pen<span class="op">=</span>method_pen[m], min_size<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> m <span class="op">==</span> <span class="st">'tamsd'</span>:</span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add half window size to the prediction from TA-MSD</span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a>            pred_cp <span class="op">=</span> [p <span class="op">+</span> win_size<span class="op">//</span><span class="dv">2</span> <span class="cf">for</span> p <span class="kw">in</span> pred_cp]</span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a>        metrics <span class="op">=</span> evaluate_cp_prediction(true_cp, pred_cp,</span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a>                                         changepoint_threshold<span class="op">=</span>threshold)</span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a>        metrics_method[m] <span class="op">=</span> merge_dict(metrics, metrics_method[m])</span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> k, v <span class="kw">in</span> metrics.items():</span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> metrics[<span class="st">'tp'</span>]:</span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a>                ds.loc[i, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> v[<span class="dv">0</span>] <span class="cf">if</span> k <span class="op">==</span> <span class="st">'sq_error'</span> <span class="cf">else</span> v</span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a>                ds.loc[i, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_</span><span class="sc">{</span>k<span class="sc">}</span><span class="ss">'</span>] <span class="op">=</span> <span class="op">-</span><span class="dv">1</span> <span class="cf">if</span> k <span class="op">==</span> <span class="st">'sq_error'</span> <span class="cf">else</span> v</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can compute the overall JI and MSE for both approaches over the whole test set.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>method_mse, method_j_idx <span class="op">=</span> {}, {}</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, v <span class="kw">in</span> metrics_method.items():</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>    method_mse[m] <span class="op">=</span> np.mean(v[<span class="st">'sq_error'</span>])</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    tp, fp, fn <span class="op">=</span> np.<span class="bu">sum</span>(v[<span class="st">'tp'</span>]), np.<span class="bu">sum</span>(v[<span class="st">'fp'</span>]), np.<span class="bu">sum</span>(v[<span class="st">'fn'</span>])</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    method_j_idx[m] <span class="op">=</span> jaccard_index(tp, fp, fn)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># code-fold: true</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Jaccard index:"</span>)</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, ji <span class="kw">in</span> method_j_idx.items():</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>ji<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"MSE:"</span>)</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m, ji <span class="kw">in</span> method_mse.items():</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"  </span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>ji<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Jaccard index:
  pred: 0.515
  tamsd: 0.297
MSE:
  pred: 35.011
  tamsd: 71.276</code></pre>
</div>
</div>
<p>Running the changepoint detection algorithm over the STEP predictions provides a massive advantage with respect to the sliding window TA-MSD baseline. We reduce the changepoint prediction error by about <span class="math inline">\(30\%\)</span> and we cut the MSE by half.</p>
<p>However, the changepoint detection task for <span class="math inline">\(\alpha\)</span> proves to be significantly more challenging than for <span class="math inline">\(D\)</span>, where we achieve mean JI over 0.8, as we saw in the <a href="https://borjarequena.github.io/step/tutorials/analysis_bm.html#overall-performance-1">Brownian motion benchmark</a>.</p>
</section>
<section id="difference-between-segments" class="level2">
<h2 class="anchored" data-anchor-id="difference-between-segments">Difference between segments</h2>
<p>Just like we did for the diffusion coefficient, we can look at how the jaccard index behaves as function of the difference between consecutive segments.</p>
<p>We start by computing the difference between consecutive <span class="math inline">\(\alpha\)</span> in each trajectory.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>ds[<span class="st">'cp'</span>] <span class="op">=</span> ds.cp.<span class="bu">apply</span>(<span class="kw">lambda</span> x: x[<span class="dv">0</span>].item())</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>ds[<span class="st">'alpha_diff'</span>] <span class="op">=</span> ds.exps.<span class="bu">apply</span>(<span class="kw">lambda</span> x: <span class="bu">round</span>((x[<span class="dv">1</span>] <span class="op">-</span> x[<span class="dv">0</span>]).item(), <span class="dv">2</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can compute the metrics.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>differences <span class="op">=</span> np.unique(ds.alpha_diff)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>j_idx_by_diff <span class="op">=</span> {m: [] <span class="cf">for</span> m <span class="kw">in</span> methods}</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> diff <span class="kw">in</span> differences:</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> ds.alpha_diff <span class="op">==</span> diff</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="kw">in</span> methods:</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>        tp <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_tp'</span>].<span class="bu">sum</span>()</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>        fp <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_fp'</span>].<span class="bu">sum</span>()</span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>        fn <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_fn'</span>].<span class="bu">sum</span>()</span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>        j_idx_by_diff[m].append(jaccard_index(tp, fp, fn))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>method_color <span class="op">=</span> {<span class="st">'pred'</span>: colors[<span class="dv">0</span>], <span class="st">'displ'</span>: colors_light[<span class="dv">3</span>], <span class="st">'tamsd'</span>: colors[<span class="dv">2</span>]}</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>method_label <span class="op">=</span> {<span class="st">'pred'</span>: <span class="st">'KCPD + STEP'</span>, <span class="st">'displ'</span>: <span class="st">'KCPD + displ'</span>, <span class="st">'tamsd'</span>: <span class="st">'KCPD + TA-MSD'</span>}</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>method_ls <span class="op">=</span> {<span class="st">'pred'</span>: <span class="st">'solid'</span>, <span class="st">'displ'</span>: <span class="st">'dashed'</span>, <span class="st">'tamsd'</span>: <span class="st">'dashed'</span>}</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="fl">1.4</span><span class="op">*</span>fig_size, fig_size))</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m <span class="kw">in</span> methods:</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    plt.plot(differences, j_idx_by_diff[m], linewidth<span class="op">=</span>linewidth, label<span class="op">=</span>method_label[m],</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>             color<span class="op">=</span>method_color[m], linestyle<span class="op">=</span>method_ls[m])</span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span>alpha_grid)</span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>plt.xlim([<span class="op">-</span><span class="fl">2.2</span>, <span class="fl">2.2</span>])</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>plt.xticks([<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>])</span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">1.05</span>])</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="fl">0.</span>, <span class="fl">0.5</span>, <span class="fl">1.</span>])</span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="vs">r"$\alpha_2 - \alpha_1$"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Jaccard index"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>plt.tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-45-output-1.png" class="img-fluid"></p>
</div>
</div>
<section id="change-point-position" class="level3">
<h3 class="anchored" data-anchor-id="change-point-position">Change point position</h3>
<div class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>bins_cp <span class="op">=</span> np.arange(<span class="dv">10</span>, <span class="dv">200</span>, <span class="dv">10</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>j_idx_by_position <span class="op">=</span> {m: [] <span class="cf">for</span> m <span class="kw">in</span> methods}</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> low, high <span class="kw">in</span> <span class="bu">zip</span>(bins_cp[:<span class="op">-</span><span class="dv">1</span>], bins_cp[<span class="dv">1</span>:]):</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>    mask <span class="op">=</span> (low <span class="op">&lt;=</span> ds.cp) <span class="op">&amp;</span> (ds.cp <span class="op">&lt;</span> high)</span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> m <span class="kw">in</span> methods:</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>        tp <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_tp'</span>].<span class="bu">sum</span>()</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>        fp <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_fp'</span>].<span class="bu">sum</span>()</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>        fn <span class="op">=</span> ds.loc[mask, <span class="ss">f'cp_</span><span class="sc">{</span>m<span class="sc">}</span><span class="ss">_fn'</span>].<span class="bu">sum</span>()</span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>        j_idx_by_position[m].append(jaccard_index(tp, fp, fn))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="fl">1.4</span><span class="op">*</span>fig_size, fig_size))</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> m <span class="kw">in</span> methods:</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>    plt.plot(j_idx_by_position[m], linewidth<span class="op">=</span>linewidth, label<span class="op">=</span>method_label[m],</span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>              color<span class="op">=</span>method_color[m], linestyle<span class="op">=</span>method_ls[m])</span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>x_tick_idx <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">9</span>, <span class="dv">17</span>])</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>plt.xticks(x_tick_idx, </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>           [<span class="ss">f'</span><span class="sc">{</span>low<span class="sc">}</span><span class="ss">-</span><span class="sc">{</span>high<span class="sc">}</span><span class="ss">'</span> <span class="cf">for</span> low, high <span class="kw">in</span> <span class="bu">zip</span>(bins_cp[x_tick_idx], bins_cp[x_tick_idx<span class="op">+</span><span class="dv">1</span>])])</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>plt.grid(alpha<span class="op">=</span>alpha_grid)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>plt.legend(fontsize<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="op">-</span><span class="fl">0.05</span>, <span class="fl">1.05</span>])</span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>plt.yticks([<span class="fl">0.</span>, <span class="fl">0.5</span>, <span class="fl">1.</span>])</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Changepoint position"</span>, fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>plt.tick_params(labelsize<span class="op">=</span><span class="dv">14</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<p><img src="02_analysis_andi_files/figure-html/cell-47-output-1.png" class="img-fluid"></p>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script type="application/vnd.jupyter.widget-state+json">
{"state":{},"version_major":2,"version_minor":0}
</script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>